<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Coding with Honour]]></title>
  <link href="http://blog.samstokes.co.uk/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.samstokes.co.uk/"/>
  <updated>2014-03-10T03:55:28+00:00</updated>
  <id>http://blog.samstokes.co.uk/</id>
  <author>
    <name><![CDATA[Sam Stokes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Regex Style in Ruby]]></title>
    <link href="http://blog.samstokes.co.uk/blog/2009/11/20/regex-style-in-ruby/"/>
    <updated>2009-11-20T22:03:00+00:00</updated>
    <id>http://blog.samstokes.co.uk/blog/2009/11/20/regex-style-in-ruby</id>
    <content type="html"><![CDATA[<!--
vim:ft=mkd
-->




<p>Reading Patrick McKenzie&#8217;s excellent <a href="http://www.kalzumeus.com/2009/11/17/practical-metaprogramming-with-ruby-storing-preferences/">practical example of metaprogramming</a>, I came across a line of code I didn&#8217;t understand:</p>


<p><code>ruby
caller[0][/`([^']*)'/, 1]
</code></p>

<p>That line taught me three new things about Ruby:</p>




<!-- more -->




<ol><li>The syntax for the subscript operator <code>[]</code> allows multiple arguments.  (It turns out I already knew this in another context: <code>[1,1,2,3,5,7][2,3] =&gt; [2,3,5]</code>)</li>
<li>You can subscript a String with a Regexp, returning the first match: <code>"goal"[/[aeiou]/] =&gt; "o"</code> (<code>nil</code> is returned if there is no match).</li>
<li>If you throw in an index <code>n</code>, then you get the <code>n</code>th capturing group of the first match: <code>"xaabb"[/(.)\1/, 1] =&gt; "a"</code> (or <code>nil</code> again if no match).</li>
</ol>


<p>That last one is interesting, because it means there&#8217;s a concise way I didn&#8217;t previously know about to achieve a common regex task: checking if an input string matches a given format, and if so, extracting part of the format.  Say we want to pull out the domain from an email address, but complain if we can&#8217;t find it:</p>


<p>```ruby
&ldquo;<a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x66;&#x6f;&#x6f;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#109;">&#102;&#x6f;&#x6f;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a>&rdquo;[/@(.*)/, 1] or raise &ldquo;bad email&rdquo;</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>```</p>

<p>Before learning this trick I would have either used a temporary match object <a href="http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html"><em>a la</em> Java</a>, or gritted my teeth and used a global variable Perl-style:</p>


<p>```ruby
match = /@(.*)/.match(&ldquo;<a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#102;&#111;&#111;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#109;">&#102;&#x6f;&#x6f;&#64;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;</a>&rdquo;)
if match
  match[1]
else
  raise &ldquo;bad email&rdquo;
end</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>if &ldquo;<a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x66;&#x6f;&#111;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#102;&#x6f;&#111;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;</a>&rdquo; =~ /@(.*)/
  $1
else
  raise &ldquo;bad email&rdquo;
end</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>```</p>

<p>Both of those seem rather verbose.  They can be <a href="http://www.flickr.com/photos/trojanguy/3575375564/">golfed</a> into one-liners, but the readability starts to suffer:</p>


<p>```ruby
$1 if &ldquo;<a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x66;&#111;&#x6f;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;">&#102;&#111;&#x6f;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;</a>&rdquo; =~ /@(.*)/ or raise &ldquo;bad email&rdquo; # =&gt; &ldquo;example.com&rdquo;</p>

<p>require &lsquo;andand&rsquo;
/@(.*)/.match(&ldquo;<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#102;&#x6f;&#111;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;">&#102;&#x6f;&#x6f;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#x63;&#x6f;&#109;</a>&rdquo;).andand[1] # =&gt; &ldquo;example.com&rdquo;
```</p>

<p>So I&#8217;m left wondering what&#8217;s the most readable and/or idiomatic style for regexes in Ruby.  TMTOWTDI indeed!  Even now I know what it means, <code>"xaabb"[/(.)\1/,1]</code> makes me double-take slightly - it&#8217;s an unusual way to use <code>[]</code> - but I guess it&#8217;s just another Ruby idiosyncracy I&#8217;ll come to know and love.</p>

]]></content>
  </entry>
  
</feed>
