<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Coding with Honour]]></title>
  <link href="http://blog.samstokes.co.uk/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.samstokes.co.uk/"/>
  <updated>2014-05-02T22:04:20+00:00</updated>
  <id>http://blog.samstokes.co.uk/</id>
  <author>
    <name><![CDATA[Sam Stokes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
    
      <entry>
        <title type="html"><![CDATA[What Programming Is Like]]></title>
        <link href="http://blog.samstokes.co.uk/blog/2014/05/01/what-programming-is-like/"/>
        <updated>2014-05-01T18:24:12+00:00</updated>
        <id>http://blog.samstokes.co.uk/blog/2014/05/01/what-programming-is-like</id>
        <content type="html"><![CDATA[<p>What is programming like?</p>

<p>We in the software profession have done a terrible job of explaining to the public what it is that we do.  Everyone has interacted with a teacher or a doctor.  There are TV shows about lawyers, cops, even government officials.  However warped our impression of their day-to-day, we can relate to these professions.  TV depicts programmers as modern-day wizards, socially aloof, hacking into systems or bringing the new algorithm online just in time to stop the cyberterrorists — totally disconnected from people&rsquo;s experience of the software they use every day.  Software remains mysterious.</p>

<p>This isn&rsquo;t just a problem for awkward &ldquo;so, what do you do?&rdquo; conversations at parties.  I believe one reason why so many demographics are underrepresented in software is that unless you grew up with it, you&rsquo;re unlikely to have the faintest idea what making software is actually like.  Why would you strive — particularly against economic obstacles and systemic biases — to enter a profession you know nothing about?</p>

<h2>Programming sucks</h2>

<p>Inspired by a friend who couldn&rsquo;t see what was so hard about programming, Peter Welch wrote a <a href="http://stilldrinking.org/programming-sucks">hilarious, heartfelt and all-too-true rant</a> about what writing software is like.  His title, and answer: &ldquo;Programming Sucks&rdquo;.  The whole, long post is enjoyable reading, but here&rsquo;s a representative excerpt:</p>

<blockquote><p>Imagine joining an engineering team [&hellip;] for a bridge in a major metropolitan area. [&hellip;] The bridge was designed as a suspension bridge, but nobody actually knew how to build a suspension bridge, so they got halfway through it and then just added extra support columns to keep the thing standing, but they left the suspension cables because they&rsquo;re still sort of holding up parts of the bridge. Nobody knows which parts, but everybody&rsquo;s pretty sure they&rsquo;re important parts. [&hellip;]</p>

<p>Would you drive across this bridge? No. If it somehow got built, everybody involved would be executed. Yet some version of this dynamic wrote every single program you have ever used, banking software, websites, and a ubiquitously used program that was supposed to protect information on the internet but didn&rsquo;t.</p></blockquote>

<!-- more -->


<p>Welch brilliantly describes the nuances and stresses of trying to cobble together something useful, based on a blueprint nobody bothered to draw, out of parts designed to do almost, but not exactly, what you need them to do.</p>

<p>Reading this, I immediately wanted to send it to every friend and family member to whom I&rsquo;d failed to explain what it was I did all day.  But I didn&rsquo;t send it, because it only tells part of the story.  Programming sucks, so why do it?</p>

<p>For me, it&rsquo;s because programming is <em>amazing</em>.</p>

<h2>Why we do it</h2>

<p>Programming is like building structures out of Lego, but I never run out of Lego bricks, and if there&rsquo;s no brick with the exact shape that I need, I can <em>make</em> that brick.  I can take the structures I build and use them <em>as</em> bricks to build bigger, more ambitious structures.  I can build tools out of bricks to help me build quicker.  If I build a model city, or a crane for building model cities, I can offer them to millions of people to download and play with, in any part of the world.</p>

<p><a href="https://www.flickr.com/photos/dunechaser/2703633791"><img src="/images/lego-city.jpg" alt="Lego city" /></a></p>

<p>Fred Brooks wrote in <em>The Mythical Man-Month</em>:</p>

<blockquote><p>The programmer, like the poet, works only slightly removed from pure thought-stuff. He builds castles in the air, from air, creating by exertion of the imagination. Few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures.</p>

<p>Yet the program construct, unlike the poet&rsquo;s words, is real in the sense that it moves and works, producing visible outputs separate from the construct itself. It prints results, draws pictures, produces sounds, moves arms.</p></blockquote>

<p>One of the most liberating things about writing software is that the tools you use for it are <em>also</em> software.  Remember that Lego tool you could buy to help you pry bricks apart?  Imagine if you could build that tool <em>out of Lego bricks</em>.  We can use the skills we have for writing software to improve the tools we work with.  We can write software that makes us <em>better at writing software</em>.</p>

<p>There is a dark side, as Welch entertainingly describes.  There are deep, scary flaws in the tools and processes we use to build software.  Everything is more difficult and arcane than it should be.  We spend so much effort, after the software is &ldquo;done&rdquo;, fixing problems that should never have been possible to introduce in the first place.  Sometimes it&rsquo;s amazing that anything ever works.  But somehow, it does, and so we have smartphones, and Angry Birds, and the Internet.  Programming sucks, but look at where we are!</p>

<p>Programming gives us live video conversations with relatives around the world; a <a href="http://en.wikipedia.org/wiki/Human_Genome_Project">map of our own biology</a>; widgets that monitor oil pipelines from the inside; spreadsheets that run entire businesses; games where you build cities, or <a href="http://www.goat-simulator.com/">pretend to be a goat</a>.</p>

<p>Of course these are specialised fields, each with its own demands and disciplines, but they all start with writing apparent gibberish in a text editor.  The reach and breadth of what you can do with gibberish is remarkable.</p>

<h2>Castles in the air</h2>

<p>Programming sucks, but for me, that is cause for tremendous optimism.  We can use programming to improve programming!  We can reduce the complexity that programmers have to keep in their heads.  We can make more visual, interactive, intuitive tools for understanding the behaviour of programs.  We can make it easier to fix incorrect programs, and easier to write correct ones.  Programming is only going to get easier, and more powerful, and more accessible.</p>

<p>If we&rsquo;ve come this far — in the 60-odd years that programming has even been possible — while programming sucks, how far can we go when it doesn&rsquo;t?</p>

<p>Brooks' phrase &ldquo;building castles in the air&rdquo; was once <a href="http://en.wiktionary.org/wiki/build_castles_in_the_air">used satirically</a>, to mean chasing an impossible dream.</p>

<p>For me, <em>that&rsquo;s</em> what programming is like.</p>

<p class="credits">
Thanks to
<a href="https://www.linkedin.com/in/josephmchow">Joseph Chow</a>,
<a href="http://www.lihaco-consulting.com/">Lily Han</a>,
<a href="https://twitter.com/ConradIrwin">Conrad Irwin</a>,
<a href="http://martin.kleppmann.com/">Martin Kleppmann</a>,
<a href="https://twitter.com/LeeMallabone">Lee Mallabone</a> and
<a href="http://www.linkedin.com/in/kiranprasad">Kiran Prasad</a>
for reviewing a draft of this post.  Their feedback improved this post immeasurably.
</p>




<p class="credits">
Lego photo credit:
<a href="https://www.flickr.com/photos/dunechaser/2703633791">dunechaser</a>
</p>

]]></content>
      </entry>
    
  
    
      <entry>
        <title type="html"><![CDATA[Vim Wizardry #1]]></title>
        <link href="http://blog.samstokes.co.uk/blog/2010/07/04/vim-wizardry-1/"/>
        <updated>2010-07-04T03:24:00+00:00</updated>
        <id>http://blog.samstokes.co.uk/blog/2010/07/04/vim-wizardry-1</id>
        <content type="html"><![CDATA[<p>(I wrote this as a <a href="http://news.ycombinator.com/item?id=1485009">response</a> to an Ask Hacker News <a href="http://news.ycombinator.com/item?id=1484061">post about learning Vim</a>, but I thought it deserved a life of its own.)</p>




<p>This is one of my favourite Vim features.  Say you have the following code:</p>


<p>```
do_something_with(some + long * complicated * expression)</p>

<pre><code>                       ^
</code></pre>

<p>```</p>

<p>Say your cursor is where the caret indicates.  Typing <code>ci)</code> (&#8220;change inside parens&#8221;) in normal mode will:</p>




<ul><li>delete all the text between the two matching parens</li>
<li>place you in insert mode with the cursor between the two (now adjacent) parens</li>
<li>put the deleted text in the yank buffer so that <code>p</code> will paste it.</li>
</ul>


<p>The use case here is obviously so you can assign a name to that long complicated expression.  <code>ci)</code> is much easier than selecting it with the mouse, and keeps your hands on the keyboard where they belong ;)</p>




<!-- more -->




<p>With nested parentheses, it does what you expect (affects the text contained by the innermost matching pair to contain your cursor - try it and see).</p>




<p>Other equally useful variants:</p>




<ul><li><code>i"</code> - &#8220;inside double quotes&#8221; - everything between double quotes</li>
<li><code>i'</code> - &#8220;inside single quotes&#8221;</li>
<li><code>iw</code> - &#8220;inside word&#8221; - the word the cursor is on</li>
<li><code>is</code> - &#8220;inside sentence&#8221; - great for editing prose</li>
<li><code>ip</code> - &#8220;inside paragraph&#8221;</li>
</ul>


<p>There are also similar motions beginning with &#8220;a&#8221;:</p>




<ul><li><code>a)</code> - like <code>i)</code> but includes the parens (e.g. <code>da)</code> deletes everything inside parens and the parens themselves)</li>
<li><code>a"</code> - similarly</li>
<li><code>aw</code> - like <code>iw</code> but includes trailing whitespace.</li>
</ul>


<p>For another great taste that goes great with this, see the <a href="http://www.vim.org/scripts/script.php?script_id=1697">surround.vim</a> plugin.  To whet your appetite: six keystrokes to wrap your current selection in &lt;div&gt; tags; four to change a string from &#8220;double-quoted&#8221; to &#8216;single-quoted&#8217;.</p>

]]></content>
      </entry>
    
  
    
      <entry>
        <title type="html"><![CDATA[Regex Style in Ruby]]></title>
        <link href="http://blog.samstokes.co.uk/blog/2009/11/20/regex-style-in-ruby/"/>
        <updated>2009-11-20T22:03:00+00:00</updated>
        <id>http://blog.samstokes.co.uk/blog/2009/11/20/regex-style-in-ruby</id>
        <content type="html"><![CDATA[<!--
vim:ft=mkd
-->




<p>Reading Patrick McKenzie&#8217;s excellent <a href="http://www.kalzumeus.com/2009/11/17/practical-metaprogramming-with-ruby-storing-preferences/">practical example of metaprogramming</a>, I came across a line of code I didn&#8217;t understand:</p>


<p><code>ruby
caller[0][/`([^']*)'/, 1]
</code></p>

<p>That line taught me three new things about Ruby:</p>




<!-- more -->




<ol><li>The syntax for the subscript operator <code>[]</code> allows multiple arguments.  (It turns out I already knew this in another context: <code>[1,1,2,3,5,7][2,3] =&gt; [2,3,5]</code>)</li>
<li>You can subscript a String with a Regexp, returning the first match: <code>"goal"[/[aeiou]/] =&gt; "o"</code> (<code>nil</code> is returned if there is no match).</li>
<li>If you throw in an index <code>n</code>, then you get the <code>n</code>th capturing group of the first match: <code>"xaabb"[/(.)\1/, 1] =&gt; "a"</code> (or <code>nil</code> again if no match).</li>
</ol>


<p>That last one is interesting, because it means there&#8217;s a concise way I didn&#8217;t previously know about to achieve a common regex task: checking if an input string matches a given format, and if so, extracting part of the format.  Say we want to pull out the domain from an email address, but complain if we can&#8217;t find it:</p>


<p>```ruby
&ldquo;<a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x66;&#x6f;&#x6f;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#x6f;&#x6d;">&#102;&#111;&#x6f;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a>&rdquo;[/@(.*)/, 1] or raise &ldquo;bad email&rdquo;</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>```</p>

<p>Before learning this trick I would have either used a temporary match object <a href="http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html"><em>a la</em> Java</a>, or gritted my teeth and used a global variable Perl-style:</p>


<p>```ruby
match = /@(.*)/.match(&ldquo;<a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x66;&#x6f;&#111;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#x66;&#x6f;&#111;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>&rdquo;)
if match
  match[1]
else
  raise &ldquo;bad email&rdquo;
end</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>if &ldquo;<a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x66;&#x6f;&#111;&#x40;&#x65;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#x66;&#111;&#111;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#111;&#x6d;</a>&rdquo; =~ /@(.*)/
  $1
else
  raise &ldquo;bad email&rdquo;
end</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>```</p>

<p>Both of those seem rather verbose.  They can be <a href="http://www.flickr.com/photos/trojanguy/3575375564/">golfed</a> into one-liners, but the readability starts to suffer:</p>


<p>```ruby
$1 if &ldquo;<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x66;&#111;&#x6f;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#x6d;">&#x66;&#111;&#x6f;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;</a>&rdquo; =~ /@(.*)/ or raise &ldquo;bad email&rdquo; # =&gt; &ldquo;example.com&rdquo;</p>

<p>require &lsquo;andand&rsquo;
/@(.*)/.match(&ldquo;<a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x66;&#x6f;&#111;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;">&#x66;&#x6f;&#x6f;&#64;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a>&rdquo;).andand[1] # =&gt; &ldquo;example.com&rdquo;
```</p>

<p>So I&#8217;m left wondering what&#8217;s the most readable and/or idiomatic style for regexes in Ruby.  TMTOWTDI indeed!  Even now I know what it means, <code>"xaabb"[/(.)\1/,1]</code> makes me double-take slightly - it&#8217;s an unusual way to use <code>[]</code> - but I guess it&#8217;s just another Ruby idiosyncracy I&#8217;ll come to know and love.</p>

]]></content>
      </entry>
    
  
</feed>
