<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Coding with Honour]]></title>
  <link href="http://blog.samstokes.co.uk/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.samstokes.co.uk/"/>
  <updated>2014-05-01T20:52:15+00:00</updated>
  <id>http://blog.samstokes.co.uk/</id>
  <author>
    <name><![CDATA[Sam Stokes]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
    
  
    
      <entry>
        <title type="html"><![CDATA[Vim Wizardry #1]]></title>
        <link href="http://blog.samstokes.co.uk/blog/2010/07/04/vim-wizardry-1/"/>
        <updated>2010-07-04T03:24:00+00:00</updated>
        <id>http://blog.samstokes.co.uk/blog/2010/07/04/vim-wizardry-1</id>
        <content type="html"><![CDATA[<p>(I wrote this as a <a href="http://news.ycombinator.com/item?id=1485009">response</a> to an Ask Hacker News <a href="http://news.ycombinator.com/item?id=1484061">post about learning Vim</a>, but I thought it deserved a life of its own.)</p>




<p>This is one of my favourite Vim features.  Say you have the following code:</p>


<p>```
do_something_with(some + long * complicated * expression)</p>

<pre><code>                       ^
</code></pre>

<p>```</p>

<p>Say your cursor is where the caret indicates.  Typing <code>ci)</code> (&#8220;change inside parens&#8221;) in normal mode will:</p>




<ul><li>delete all the text between the two matching parens</li>
<li>place you in insert mode with the cursor between the two (now adjacent) parens</li>
<li>put the deleted text in the yank buffer so that <code>p</code> will paste it.</li>
</ul>


<p>The use case here is obviously so you can assign a name to that long complicated expression.  <code>ci)</code> is much easier than selecting it with the mouse, and keeps your hands on the keyboard where they belong ;)</p>




<!-- more -->




<p>With nested parentheses, it does what you expect (affects the text contained by the innermost matching pair to contain your cursor - try it and see).</p>




<p>Other equally useful variants:</p>




<ul><li><code>i"</code> - &#8220;inside double quotes&#8221; - everything between double quotes</li>
<li><code>i'</code> - &#8220;inside single quotes&#8221;</li>
<li><code>iw</code> - &#8220;inside word&#8221; - the word the cursor is on</li>
<li><code>is</code> - &#8220;inside sentence&#8221; - great for editing prose</li>
<li><code>ip</code> - &#8220;inside paragraph&#8221;</li>
</ul>


<p>There are also similar motions beginning with &#8220;a&#8221;:</p>




<ul><li><code>a)</code> - like <code>i)</code> but includes the parens (e.g. <code>da)</code> deletes everything inside parens and the parens themselves)</li>
<li><code>a"</code> - similarly</li>
<li><code>aw</code> - like <code>iw</code> but includes trailing whitespace.</li>
</ul>


<p>For another great taste that goes great with this, see the <a href="http://www.vim.org/scripts/script.php?script_id=1697">surround.vim</a> plugin.  To whet your appetite: six keystrokes to wrap your current selection in &lt;div&gt; tags; four to change a string from &#8220;double-quoted&#8221; to &#8216;single-quoted&#8217;.</p>

]]></content>
      </entry>
    
  
    
      <entry>
        <title type="html"><![CDATA[Regex Style in Ruby]]></title>
        <link href="http://blog.samstokes.co.uk/blog/2009/11/20/regex-style-in-ruby/"/>
        <updated>2009-11-20T22:03:00+00:00</updated>
        <id>http://blog.samstokes.co.uk/blog/2009/11/20/regex-style-in-ruby</id>
        <content type="html"><![CDATA[<!--
vim:ft=mkd
-->




<p>Reading Patrick McKenzie&#8217;s excellent <a href="http://www.kalzumeus.com/2009/11/17/practical-metaprogramming-with-ruby-storing-preferences/">practical example of metaprogramming</a>, I came across a line of code I didn&#8217;t understand:</p>


<p><code>ruby
caller[0][/`([^']*)'/, 1]
</code></p>

<p>That line taught me three new things about Ruby:</p>




<!-- more -->




<ol><li>The syntax for the subscript operator <code>[]</code> allows multiple arguments.  (It turns out I already knew this in another context: <code>[1,1,2,3,5,7][2,3] =&gt; [2,3,5]</code>)</li>
<li>You can subscript a String with a Regexp, returning the first match: <code>"goal"[/[aeiou]/] =&gt; "o"</code> (<code>nil</code> is returned if there is no match).</li>
<li>If you throw in an index <code>n</code>, then you get the <code>n</code>th capturing group of the first match: <code>"xaabb"[/(.)\1/, 1] =&gt; "a"</code> (or <code>nil</code> again if no match).</li>
</ol>


<p>That last one is interesting, because it means there&#8217;s a concise way I didn&#8217;t previously know about to achieve a common regex task: checking if an input string matches a given format, and if so, extracting part of the format.  Say we want to pull out the domain from an email address, but complain if we can&#8217;t find it:</p>


<p>```ruby
&ldquo;<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x66;&#x6f;&#111;&#64;&#101;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#x66;&#111;&#x6f;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a>&rdquo;[/@(.*)/, 1] or raise &ldquo;bad email&rdquo;</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>```</p>

<p>Before learning this trick I would have either used a temporary match object <a href="http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html"><em>a la</em> Java</a>, or gritted my teeth and used a global variable Perl-style:</p>


<p>```ruby
match = /@(.*)/.match(&ldquo;<a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#102;&#111;&#111;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#102;&#x6f;&#x6f;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a>&rdquo;)
if match
  match[1]
else
  raise &ldquo;bad email&rdquo;
end</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>if &ldquo;<a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x66;&#x6f;&#111;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#102;&#111;&#111;&#x40;&#x65;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a>&rdquo; =~ /@(.*)/
  $1
else
  raise &ldquo;bad email&rdquo;
end</p>

<h1>=&gt; &ldquo;example.com&rdquo;</h1>

<p>```</p>

<p>Both of those seem rather verbose.  They can be <a href="http://www.flickr.com/photos/trojanguy/3575375564/">golfed</a> into one-liners, but the readability starts to suffer:</p>


<p>```ruby
$1 if &ldquo;<a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x66;&#x6f;&#x6f;&#x40;&#x65;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#x66;&#111;&#x6f;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a>&rdquo; =~ /@(.*)/ or raise &ldquo;bad email&rdquo; # =&gt; &ldquo;example.com&rdquo;</p>

<p>require &lsquo;andand&rsquo;
/@(.*)/.match(&ldquo;<a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#102;&#111;&#x6f;&#64;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#x66;&#x6f;&#x6f;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#111;&#x6d;</a>&rdquo;).andand[1] # =&gt; &ldquo;example.com&rdquo;
```</p>

<p>So I&#8217;m left wondering what&#8217;s the most readable and/or idiomatic style for regexes in Ruby.  TMTOWTDI indeed!  Even now I know what it means, <code>"xaabb"[/(.)\1/,1]</code> makes me double-take slightly - it&#8217;s an unusual way to use <code>[]</code> - but I guess it&#8217;s just another Ruby idiosyncracy I&#8217;ll come to know and love.</p>

]]></content>
      </entry>
    
  
</feed>
